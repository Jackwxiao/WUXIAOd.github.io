<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>吴潇的个人博客  | vue-router、axios、vuex</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="vue-router、axios、vuex" />
<meta property="og:description" content="vue-router 路由的基本加载  安装 npm install --save vue-router 2.引用
在router 的index.js中 import router from &#39;vue-router&#39; Vue.use(router)  配置路由文件，并在vue实例中注入
var rt = new router({ routes:[{ path:&#39;/&#39;, //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 }] }) new Vue({ el: &#39;#app&#39;, router, components: { App }, template: &#39;&#39; })  确定试图加载的位置
&lt;router-view&gt;&lt;/router-view&gt;  路由的跳转  &lt;template&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH 33&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD 22&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;   路由参数传递  必须在路由内加入路由的name ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/vue-routeraxiosvuex/" />
<meta property="article:published_time" content="2019-10-15T20:30:30+09:00" />
<meta property="article:modified_time" content="2019-10-15T20:30:30+09:00" />
<meta itemprop="name" content="vue-router、axios、vuex">
<meta itemprop="description" content="vue-router 路由的基本加载  安装 npm install --save vue-router 2.引用
在router 的index.js中 import router from &#39;vue-router&#39; Vue.use(router)  配置路由文件，并在vue实例中注入
var rt = new router({ routes:[{ path:&#39;/&#39;, //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 }] }) new Vue({ el: &#39;#app&#39;, router, components: { App }, template: &#39;&#39; })  确定试图加载的位置
&lt;router-view&gt;&lt;/router-view&gt;  路由的跳转  &lt;template&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH 33&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD 22&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;   路由参数传递  必须在路由内加入路由的name .">


<meta itemprop="datePublished" content="2019-10-15T20:30:30&#43;09:00" />
<meta itemprop="dateModified" content="2019-10-15T20:30:30&#43;09:00" />
<meta itemprop="wordCount" content="390">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="vue-router、axios、vuex"/>
<meta name="twitter:description" content="vue-router 路由的基本加载  安装 npm install --save vue-router 2.引用
在router 的index.js中 import router from &#39;vue-router&#39; Vue.use(router)  配置路由文件，并在vue实例中注入
var rt = new router({ routes:[{ path:&#39;/&#39;, //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 }] }) new Vue({ el: &#39;#app&#39;, router, components: { App }, template: &#39;&#39; })  确定试图加载的位置
&lt;router-view&gt;&lt;/router-view&gt;  路由的跳转  &lt;template&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH 33&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD 22&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;   路由参数传递  必须在路由内加入路由的name ."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://example.org/" class="f3 fw2 hover-white no-underline white-90 dib">
      吴潇的个人博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">vue-router、axios、vuex</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2019-10-15T20:30:30&#43;09:00">October 15, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="vue-router">vue-router</h2>

<h4 id="路由的基本加载">路由的基本加载</h4>

<ol>
<li><p>安装
<code>npm install --save vue-router</code>
2.引用</p>

<pre><code>在router 的index.js中 import router from 'vue-router'
Vue.use(router)
</code></pre></li>

<li><p>配置路由文件，并在vue实例中注入</p>

<pre><code>var rt = new router({ 
routes:[{ 
path:'/', //指定要跳转的路径 
component: HelloWorld //指定要跳转的组件
}] 
}) 
new Vue({ 
el: '#app',
router, 
components: { App }, 
template: '' 
})
</code></pre></li>

<li><p>确定试图加载的位置</p>

<pre><code>&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>

<h4 id="路由的跳转">路由的跳转</h4>

<pre><code>
&lt;template&gt;
    &lt;ul&gt;
        &lt;li&gt; 
           &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH 33&lt;/router-link&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD 22&lt;/router-link&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

</code></pre></li>
</ol>

<h4 id="路由参数传递">路由参数传递</h4>

<ul>
<li>必须在路由内加入路由的name</li>
<li>.必须在path后加/: +传递的参数</li>
</ul>

<p>传递参数：
<router-link :to="{name：helloearth,params:{msg: xxxxx}}">
HELLO WORLD
</router-link>
读取参数：
 $route.params.msg</p>

<h2 id="axios">Axios</h2>

<h4 id="简介">简介</h4>

<p>Axios是一个基于Promise用于浏览器和nodejs的HTTP客户端，它本身具有以下特征：
* 从浏览器中创建 XMLHttpRequest
* 从node.js 发出http请求
* 支持Promise API
* 拦截请求和响应
* 转换请求和响应数据
* 取消请求
* 自动转换JSON数据
* 客户端支持防止 CSRF/XSRF</p>

<h4 id="get请求">get请求：</h4>

<ol>
<li><p>安装</p>

<pre><code>npm install axios
</code></pre></li>

<li><p>引入加载</p>

<pre><code>import axios from 'axios' 
</code></pre></li>

<li><p>将axios全局挂载到VUE原型上</p>

<pre><code>Vue.prototype.$http = axios;
</code></pre></li>

<li><p>发出请求 以cnode社区API为例子</p>

<pre><code>
&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
   &lt;h3&gt;这是axios项目，用来发送请求，拦截响应&lt;/h3&gt;
   &lt;button @click='getData'&gt;GET方式发送请求&lt;/button&gt;
   &lt;ul&gt;
     &lt;li v-for=&quot;item in items&quot;&gt;
       {{item.title}}
     &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
Vue.prototype.$http = axios  //将axios 全局挂载到Vue原型上
import axios from 'axios' //引入加载
import Vue from 'vue'

export default {
  name: 'HelloWorld',
  data () {
    return {
      items:[]
    }
  },
  methods:{
    getData(){//请求以cnode社区API为例子
      this.$http.get('https://cnodejs.org/api/v1/topics',{
        params:{//这是参数
          page: 2,
          limit:5
        }
      })
      .then((res)=&gt;{//此处用了ES6语法，不用箭头函数下面使用this.items 会出错
        this.items = res.data.data
        console.log(this.items)
      })
      .catch((err)=&gt;{
        console.log(err)
      })
    }
  }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre></li>
</ol>

<p>参数：page页码
limit 每页显示的数量</p>

<h4 id="post请求">post请求：</h4>

<p>POST传递数据有两种格式：
* form-data ？page=1&amp;limit=48</p>

<ul>
<li>x-www-form-urlencoded { page: 1,limit: 10 }</li>
</ul>

<p>在axios中，post请求接收的参数必须是form-data
qs插件—qs.stringify</p>

<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
   &lt;h3&gt;这是axios项目，用来发送请求，拦截响应&lt;/h3&gt;
   &lt;button @click='postData'&gt;post方式发送请求&lt;/button&gt;
   &lt;ul&gt;
     &lt;li v-for=&quot;item in items&quot;&gt;
       {{item.title}}
     &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

Vue.prototype.$http = axios  //将axios 全局挂载到Vue原型上
import Vue from 'vue'
import qs from 'qs'

export default {
  name: 'HelloWorld',
  data () {
    return {
      items:[]
    }
  },
  methods:{
  postData(){
      this.$http.post(url,qs.stringify({
        params:{//这里的参数必须经过qs插件使用stringify使其格式为 form-data 
        //因为在axios中，post请求接收的参数必须是 form-data
          page: 2,
          limit:5
        }
      }))
      .then((res)=&gt;{
        this.items = res.data.data
        console.log(this.items)
      })
      .catch((err)=&gt;{
        console.log(err)
      })
    }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>

<h2 id="vuex">Vuex</h2>

<p>用来管理状态，共享数据，在各个组件之间管理外部状态
比如说，用于在每个页面（组件）都要判断用户是否是登录状态，如果没登陆则要求登录。
创建一个状态仓库，每个组件都能共享这个状态仓库。</p>

<ol>
<li><p>父组件给子组件传递数据，首先父组件的data属性中必须得有这个数据（:msg=&ldquo;toSonMsg&rdquo;），其次子组件中必须得有一个props来接受数据(msg:{
type:String, default : &lsquo; &rsquo; })，然后在页面渲染就行了（{{msg}}）</p></li>

<li><p>子组件给父组件传递数据，在父组件模板下面的渲染的子组件中先定义一个自定义事件</p>

<pre><code>&lt;son @handle=&quot;getSonMsg&quot;&gt;&lt;/son&gt; 
</code></pre></li>
</ol>

<p>子组件模板中定义一个</p>

<pre><code>&lt;button @click=&quot;senMsgFa&quot;&gt;&lt;/button&gt;
</code></pre>

<p>在子组件还要定义一个senMsgFa方法</p>

<pre><code>methods:{
   senMsgFa:function(){
   this.$emit('handle',要传给父组件的数据)
   }
}
</code></pre>

<p>之后在子组件的data属性中定义要传给父组件的数据toFaMsg</p>

<pre><code>data:function(){
    return{
      toFaMsg:'这是子组件传给父组件的'
    }
  }
</code></pre>

<p>然后上面$emit中的第二个参数就是this.toFaMsg，也就是</p>

<pre><code>this.$emit('handle',this.toFaMsg)
</code></pre>

<p>点击按钮触发handle事件之后就会把toFaMsg传递出去，父组件中getSonMsg方法中的参数value就是传进来的toFaMsg，这时候只要把value赋值给this.fromSonMsg,然后渲染出来就行了{{fromSonMsg}}</p>

<p><strong>由上可知，子父组件之间相互可以随意传递数据，如果有”第三者“组件的诞生呢，虽然可以让第三者也成为子父组件关系，但如果组件数量逐渐增多，这种办法就不现实了，于是，用Vuex吧。</strong></p>

<h4 id="使用vuex需要安装vuex插件">使用Vuex需要安装vuex插件</h4>

<pre><code>npm install vuex
</code></pre>

<h4 id="引入vuex-并vue-use-vuex">引入vuex，并Vue.use（Vuex）</h4>

<pre><code>//在main.js中
import Vuex from 'vuex'
Vue.use(Vuex)
</code></pre>

<h4 id="创建状态仓库-store-state不能改">创建状态仓库：Store、state不能改</h4>

<pre><code>//在main.js 中
var store = new Vuex.Store({
    state:{
        num: 99
    }
})
//然后在main.js中注入store（和router类似）
</code></pre>

<h4 id="共享数据">共享数据</h4>

<p>如果每个组件都需要这个状态：那就每个组件都设置一个计算属性</p>

<pre><code> computed:{
   getNum:function(){
    return this.$store.state.num
    }
 }
</code></pre>

<p>然后再渲染出来{{getNum}}</p>

<h4 id="操作状态">操作状态</h4>

<p>main.js</p>

<pre><code>//创建状态仓库
var store = new Vuex.Store({
    state:{
      num: 99
    },
    mutations:{//定义状态改变函数
      increase(state){//ES6写法
        state.num=state.num+20
      },
      decrease:function(state){
        state.num=state.num-20
      }
    },
    actions:{
       //context 上下文对象
      decreaseActions:function(context){
        //actions中只能对mutation进行操作
        context.commit('decrease')
      }
    },
    getters:{
      getNum(state){
        return state.num &gt; 0 ? state.num : 0
      }
    }
})
</code></pre>

<ul>
<li>各组件通过this.$store.commit(&lsquo;increase&rsquo;)来直接操作state &mdash;&mdash;mutation</li>
<li>通过this.$store.dispatch(&lsquo;decrease&rsquo;)来间接操作state &mdash;&mdash;actions</li>
</ul>

<p><strong>mutation与actios的区别：</strong>
1. 参数不同：
mutation参数为state，actions参数为context
2. 调用方式不同：
前者通过：<code>this.$store.commit()</code>
后者通过：<code>this.$store.dispatch()</code>
3. 函数要求不同：
actions中可以使用异步操作，mutation中只能同步</p>

<p>vuex状态管理操作的流程：
view-&gt;actions-&gt;mutation-&gt;state-&gt;view
对state进行直接操作的是mutation，actions如果没有异步操作可以省略。</p>

<p><strong>后面优化时再单独创建store&gt;index.js文件，再把vuex相关的代码放到里面，类似vue-router</strong></p>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy; 2019 吴潇的个人博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
