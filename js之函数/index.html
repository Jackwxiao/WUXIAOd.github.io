<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="吴潇">
  <meta name="description" content="吴潇的个人网站">
  <meta name="keywords" content="吴潇,前端,程序猿">
  
  <link rel="prev" href="http://www.pigxw.top/js%E6%A8%A1%E6%8B%9F%E7%BB%A7%E6%89%BF/" />
  <link rel="next" href="http://www.pigxw.top/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" />
  <link rel="canonical" href="http://www.pigxw.top/js%E4%B9%8B%E5%87%BD%E6%95%B0/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           JS之函数 | 吴潇的个人博客
       
  </title>
  <meta name="title" content="JS之函数 | 吴潇的个人博客">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/www.pigxw.top\/"
    },
    "articleSection" : "posts",
    "name" : "JS之函数",
    "headline" : "JS之函数",
    "description" : "函数 指可以执行代码的对象，和数组一样有不一致性。\n三种函数声明方式 function f() { } var f = function f() { }; \/\/注意分号 f = new Function (\x27x\x27,\x27y\x27,\x27return x\x2by\x27) \/\/只有最后一个参数会被当作函数体，可以不使用new 命令，不推荐使用这种声明方式  注意：如果同一个函数被多次声明，后面的声明会覆盖前面的声明。也就是说起前面的声明会失效。\n函数名的提升 JS引擎将函数名视同变量名，使用function 声明函数时，整个函数会像变量声明一样被提升到代码头部。如果同时使用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义\nvar f = function () { console.log(\x271\x27); } function f() { console.log(\x272\x27); } f() \/\/ 1  函数的属性和方法  name : f.name返回函数的名字，如果通过变量赋值定义的匿名函数则返回变量名。具名函数返回function关键字后的函数名。\nvar f3 = function myName() {}; f3.name \/\/ \x27myName\x27   上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 用处：可用来获取参数函数的名字。\n length: f.length 返回函数预期传入的参数个数。\n toString: 返回一个字符串，内容是函数源码。",
    "inLanguage" : "zh-CN",
    "author" : "吴潇",
    "creator" : "吴潇",
    "publisher": "吴潇",
    "accountablePerson" : "吴潇",
    "copyrightHolder" : "吴潇",
    "copyrightYear" : "2019",
    "datePublished": "2019-10-23 19:21:26 \x2b0800 CST",
    "dateModified" : "2019-10-23 19:21:26 \x2b0800 CST",
    "url" : "http:\/\/www.pigxw.top\/js%E4%B9%8B%E5%87%BD%E6%95%B0\/",
    "wordCount" : "223",
    "keywords" : [  "吴潇的个人博客"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://www.pigxw.top/">吴潇的个人博客</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/search/" title="">搜索</a>
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/contacts/" title="">联系我</a>
                
                <a class="menu-item" href="/wechat-subscribe/" title="">订阅</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://www.pigxw.top/">吴潇的个人博客</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/search/" title="">搜索</a>
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/contacts/" title="">联系我</a>
                
                <a class="menu-item" href="/wechat-subscribe/" title="">订阅</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">JS之函数</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="http://www.pigxw.top/" rel="author">吴潇</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-10-23 itemprop="datePublished">October 23, 2019</time>
                </span>
                in
                
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h2 id="函数">函数</h2>

<p>指可以执行代码的对象，和数组一样有不一致性。</p>

<h5 id="三种函数声明方式">三种函数声明方式</h5>

<pre><code>function f() { }
var f = function f() { }; //注意分号
f = new Function ('x','y','return x+y') //只有最后一个参数会被当作函数体，可以不使用new 命令，不推荐使用这种声明方式
</code></pre>

<p><strong>注意：如果同一个函数被多次声明，后面的声明会覆盖前面的声明。也就是说起前面的声明会失效。</strong></p>

<h4 id="函数名的提升">函数名的提升</h4>

<p>JS引擎将函数名视同变量名，使用function 声明函数时，整个函数会像变量声明一样被提升到代码头部。如果同时使用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义</p>

<pre><code>var f = function () {
  console.log('1');
}
function f() {
  console.log('2');
}

f() // 1
</code></pre>

<h4 id="函数的属性和方法">函数的属性和方法</h4>

<ul>
<li><p>name :  f.name返回函数的名字，如果通过变量赋值定义的匿名函数则返回变量名。具名函数返回function关键字后的函数名。</p>

<pre><code>var f3 = function myName() {};
f3.name // 'myName'
</code></pre></li>
</ul>

<p>上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。
<strong>用处：可用来获取参数函数的名字。</strong></p>

<ul>
<li><p>length: f.length 返回函数预期传入的参数个数。</p></li>

<li><p>toString: 返回一个字符串，内容是函数源码。</p></li>
</ul>

<h4 id="作用域">作用域</h4>

<p>作用域（scope）指的是变量存在的范围。
在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域。</p>

<p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。
在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。
函数内部定义的变量，会在该作用域内覆盖同名全局变量。函数内部的变量也会提升。</p>

<h4 id="参数">参数</h4>

<p>参数可以省略，但没办法只省略靠前的参数而保留后面的参数，若必须省略靠前的参数，只能显示传入 undefined。
传递方式：函数参数如果是原始类型的值，传递方式是传值传递，这意味着在函数体内部修改参数值不会影响到函数外部。如果函数参数是复合类型的值，传递方式是传址传递，也就是说，传入函数的原始值的地址，因此在函数内部修改参数将会影响到原始值。</p>

<pre><code>var obj = { p: 1 };
function f(o) {
  o.p = 2;
}

f(obj);
obj.p // 2
</code></pre>

<p>上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。</p>

<p><strong>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。如果有同名函数，则取最后出现出现的值。</strong></p>

<pre><code>function f(a, a) {
  console.log(a);
}

f(1) // undefined
function f(a, a) {
 console.log(arguments[0]);
}

f(1) // 1
arguments对象
</code></pre>

<p>arguments对象包含了函数运行时的所有参数。arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。
正常模式下，arguments对象可以在运行时修改。</p>

<pre><code>var f = function(a, b) {
  arguments[0] = 3;
  arguments[1] = 2;
  return a + b;
}

f(1, 1) // 5
</code></pre>

<p><strong>严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。</strong></p>

<pre><code>var f = function(a, b) {
  'use strict'; // 开启严格模式
  arguments[0] = 3;
  arguments[1] = 2;
  return a + b;
}

f(1, 1) // 2
</code></pre>

<p>上面代码中，函数体内是严格模式，这时修改arguments对象，不会影响到真实参数a和b。</p>

<p>虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。
如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。
下面是两种常用的转换方法：slice方法和逐一填入新数组。</p>

<pre><code>var args = Array.prototype.slice.call(arguments);

// 或者
var args = [];
for (var i = 0; i &lt; arguments.length; i++) {
  args.push(arguments[i]);
}
</code></pre>

<h4 id="闭包">闭包</h4>

<p>一个函数如果使用了它范围外的变量，那么这个函数+这个变量就是一个闭包。</p>

<pre><code>function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999
</code></pre>

<p>上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。</p>

<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>

<p><strong>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</strong>
本文内容摘自(<a href="https://wangdoc.com/javascript/types/function.html" rel="nofollow noreferrer" target="_blank">https://wangdoc.com/javascript/types/function.html</a>)</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>吴潇 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=http://www.pigxw.top/js%E4%B9%8B%E5%87%BD%E6%95%B0/>http://www.pigxw.top/js%E4%B9%8B%E5%87%BD%E6%95%B0/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="http://www.pigxw.top/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="http://www.pigxw.top/js%E6%A8%A1%E6%8B%9F%E7%BB%A7%E6%89%BF/" class="prev" rel="prev" title="JS模拟继承"><i class="iconfont icon-left"></i>&nbsp;JS模拟继承</a>
         
        
        <a href="http://www.pigxw.top/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" class="next" rel="next" title="移动端适配方案">移动端适配方案&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="http://www.pigxw.top/">吴潇</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
