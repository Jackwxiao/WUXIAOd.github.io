<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="吴潇">
  <meta name="description" content="吴潇的个人网站">
  <meta name="keywords" content="吴潇,前端,程序猿">
  
  <link rel="prev" href="http://www.pigxw.top/%E5%8A%A8%E6%80%81rem/" />
  <link rel="next" href="http://www.pigxw.top/bfc/" />
  <link rel="canonical" href="http://www.pigxw.top/promise/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Promise | 吴潇的个人博客
       
  </title>
  <meta name="title" content="Promise | 吴潇的个人博客">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/www.pigxw.top\/"
    },
    "articleSection" : "posts",
    "name" : "Promise",
    "headline" : "Promise",
    "description" : "异步与Promise 如果 JS 不能直接拿到一个函数的结果，可以先去执行别的代码，等结果到了再取结果，这就是异步\n异步的结果可以通过轮询获取，轮询就是定时去询问结果拿到了没有\n异步的结果可以通过回调获取，一般来说结果会被作为回调的第一个参数\n异步的好处是可以把用来等待的时间拿去做别的事情\npromise的由来  promise 是现在前端解决异步问题的统一方案！！！！\nPromise 不是前端发明的\nwindow.Promise 是一个全局函数，可以用来构造 Promise 对象\n使用 return new Promise((resolve, reject)=\x26gt; {}) 就可以构造一个 Promise 对象\n构造出来的 Promise 对象含有一个 .then() 函数属性\nresolve 和 reject 都只接受一个参数\nresolve 和 reject 并不是 .then(succes, fail) 里面的 success 和 fail，resolve 会去调用 \x26gt;success，reject 会去调用 fail 插一道面试题：\n const array= [\x271\x27,\x272\x27,\x273\x27].map( parseInt） console.log( array ) \/\/ [1,NaN,NaN]  只能这样写：\nconst array= [\x271\x27,\x272\x27,\x273\x27].map( item =\x26gt;parseInt(item)） console.log( array ) \/\/ [1,2,3]  异步任务拿不到结果，于是传一个回调给异步任务，异步任务完成时调用回调，调用的时候把结果作为参数。 如果有两结果呢，比如成功和失败",
    "inLanguage" : "zh-CN",
    "author" : "吴潇",
    "creator" : "吴潇",
    "publisher": "吴潇",
    "accountablePerson" : "吴潇",
    "copyrightHolder" : "吴潇",
    "copyrightYear" : "2019",
    "datePublished": "2019-11-04 19:17:26 \x2b0800 CST",
    "dateModified" : "2019-11-04 19:17:26 \x2b0800 CST",
    "url" : "http:\/\/www.pigxw.top\/promise\/",
    "wordCount" : "389",
    "keywords" : [  "吴潇的个人博客"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://www.pigxw.top/">吴潇的个人博客</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/search/" title="">搜索</a>
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/contacts/" title="">联系我</a>
                
                <a class="menu-item" href="/wechat-subscribe/" title="">订阅</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://www.pigxw.top/">吴潇的个人博客</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/search/" title="">搜索</a>
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/contacts/" title="">联系我</a>
                
                <a class="menu-item" href="/wechat-subscribe/" title="">订阅</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Promise</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="http://www.pigxw.top/" rel="author">吴潇</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-11-04 itemprop="datePublished">November 4, 2019</time>
                </span>
                in
                
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h2 id="异步与promise">异步与Promise</h2>

<p>如果 JS 不能直接拿到一个函数的结果，可以先去执行别的代码，等结果到了再取结果，这就是异步<br>
异步的结果可以通过轮询获取，轮询就是定时去询问结果拿到了没有<br>
异步的结果可以通过回调获取，一般来说结果会被作为回调的第一个参数<br>
异步的好处是可以把用来等待的时间拿去做别的事情</p>

<h4 id="promise的由来">promise的由来</h4>

<blockquote>
<p>promise 是现在前端解决异步问题的统一方案！！！！<br>
Promise 不是前端发明的<br>
window.Promise 是一个全局函数，可以用来构造 Promise 对象<br>
使用 return new Promise((resolve, reject)=&gt; {}) 就可以构造一个 Promise 对象<br>
构造出来的 Promise 对象含有一个 .then() 函数属性<br>
resolve 和 reject 都只接受一个参数<br>
resolve 和 reject 并不是 .then(succes, fail) 里面的 success 和 fail，resolve 会去调用 &gt;success，reject 会去调用 fail
插一道面试题：</p>
</blockquote>

<pre><code>const array=  ['1','2','3'].map( parseInt）

console.log( array )
// [1,NaN,NaN]
</code></pre>

<p>只能这样写：</p>

<pre><code>const array=  ['1','2','3'].map( item =&gt;parseInt(item)）

console.log( array )
// [1,2,3]
</code></pre>

<p>异步任务拿不到结果，于是传一个回调给异步任务，异步任务完成时调用回调，调用的时候把结果作为参数。
如果有两结果呢，比如成功和失败</p>

<ul>
<li><p>可以接收两个参数</p>

<pre><code>fs.readFile('./1.txt', ( error, data )=&gt;{
if( error ){
    console.,log('失败')；return
}
console.log(data.toString())//成功
})
</code></pre></li>

<li><p>搞两个回调</p></li>
</ul>

<p>满足某些条件的函数才被称为回调，比如我写一个函数 A，传给另一个函数 B 调用，那么函数 A 就是回调<br>
回调可以用于同步任务，不一定非要用于异步任务<br>
有的时候回调还可以传给一个对象，如 request.onreadystatechange，等待浏览器来调用</p>

<pre><code>    aiax('get', '1.json', data=&gt;{ }, error=&gt;{ })
    //前面函数是成功调用，后面失败调用
   
   ajax( 'get', '1.json' , {
    success: () =&gt;{ },  fail: ()=&gt;{ }
   })
   //接收一个对象，对象有两个 key 表示成功和失败
</code></pre>

<p>上面方法都有问题：</p>

<ol>
<li>不规范，名称五花八门</li>
<li>容易出现回调地狱，代码看不懂</li>
<li>很难进行错误处理</li>
</ol>

<p>怎么解决这三个问题？
-规范回调的名字或顺序；拒绝回调地狱，让代码可读性更强；很方便地捕获错误。</p>

<h4 id="以-ajax-的封装为例来逐步讲解-promise">以 AJAX 的封装为例来逐步讲解 Promise</h4>

<p>首先是 用回调来封装</p>

<pre><code>    ajax = (method, url, options)=&gt;{
        const { succes, fail  } = options   //es6 析构赋值
        const request = new XMLHttpRequest()
        request .open(method, url)
        request.onreadystatechange = () =&gt;{
            if(request.readyState = == 4){
              if(request.status &lt; 400){
                success.call( null , request.response)
            }else if(request.status &gt;= 400 ) {
                fail.call( null,request,request.status)
              }
        }
    }
    request.send()
} 

//封装完之后，使用ajax就只用写下面几句了

ajax('get', '/xxx',{
success(response){} , fail: (request,status) = &gt;{}
})

</code></pre>

<p>promise 说这代码太蠢了。。。。</p>

<p><strong>用promise 改写</strong></p>

<pre><code>ajax = (method,url , options)=&gt;{ 
return new Promise((resolve,reject)=&gt;{
    const { succes,fail } = options
    const request = new XMLHttpRequest() 
    request .open(method, url) 
    request.onreadystatechange = () =&gt;{ 
         if (request.readyState = == 4){ 
            if(request.status &lt; 400){ 
    resolve.call( null , request.response) 
        }else if (request.status &gt;= 400){ 
        reject.call( null,request) 
            } 
        } 
    } request.send( )
})
 }
   
   aiax('get','/xxx')
   .then( (response)=&gt;{ } , (request)=&gt;{ } )
    //虽然也是回调，但不用记 success 和 fail  了 ，then 的第一个参数就是 success , 第二个参数是 fail
    //ajax 返回一个含有 .then( )  方法的对象
</code></pre>

<p>上面封装ajax 的缺点：</p>

<ol>
<li>post 无法上传数据
<code>rquest.send(这里可以上传数据)</code></li>
<li>不能设置请求头
<code>request.setRequestHeader(key,value)</code></li>
</ol>

<p>可以使用 jQyery.ajax 或者 axios</p>

<p>不需要掌握jquery.ajax 了，现在都一般用 axios</p>

<p>axios 抄袭了jquery.ajax
它是一个专门用于操作 AJAX 的库
axios.get(&lsquo;/xxx&rsquo;) 返回一个 Promise 对象axios.get(&lsquo;/xxx&rsquo;).then(s, f) 在请求成功的时候调用 s，失败的使用调用 f</p>

<h4 id="用-promise-对象实现-ajax-操作-完善">用 Promise 对象实现 Ajax 操作(完善)</h4>

<pre><code>const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

  });

  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
</code></pre>

<p><strong>getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</strong></p>

<h4 id="手写promise">手写Promise</h4>

<pre><code>function xxx(){
return new Promise((f1,f2)=&gt;{
doSomething()
setTimeout(()=&gt;{
//成功就调用f1，失败就调用f2
}，3000)
})
}
xxx().then(success,fail)
</code></pre>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>吴潇 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=http://www.pigxw.top/promise/>http://www.pigxw.top/promise/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="http://www.pigxw.top/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="http://www.pigxw.top/%E5%8A%A8%E6%80%81rem/" class="prev" rel="prev" title="手机专用之动态 rem"><i class="iconfont icon-left"></i>&nbsp;手机专用之动态 rem</a>
         
        
        <a href="http://www.pigxw.top/bfc/" class="next" rel="next" title="BFC">BFC&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="http://www.pigxw.top/">吴潇</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
